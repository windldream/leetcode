/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
  if (initial.length === 1) {
    return initial[0];
  }
  const m = graph.length;
  const clean = Array(m).fill(1);
  for (const x of initial) {
    clean[x] = 0;
  }

  const infectedBy = Array(m)
    .fill(0)
    .map(() => new Set());
  // 构造与 initial 节点直连的图
  for (const u of initial) {
    const seen = new Set();
    dfs(graph, clean, u, seen);
    // seen 中的节点不在inital中
    for (const v of seen) {
      infectedBy[v].add(u);
    }
  }

  // 构造 inital 中直连数据的 list
  const contribution = Array(m).fill(0);
  for (let v = 0; v < m; v++) {
    if (infectedBy[v].size === 1) {
      contribution[infectedBy[v].keys().next().value] += 1;
    }
  }

  initial.sort((a, b) => a - b);
  let ans = initial[0];
  let ansSize = -1;
  for (const u of initial) {
    const score = contribution[u];
    if (score > ansSize) {
      ans = u;
      ansSize = score;
    }
  }
  return ans;

  function dfs(graph, clean, u, seen) {
    for (let v = 0; v < graph.length; v++) {
      if (graph[u][v] === 1 && clean[v] === 1 && !seen.has(v)) {
        seen.add(v);
        dfs(graph, clean, v, seen);
      }
    }
  }
};
